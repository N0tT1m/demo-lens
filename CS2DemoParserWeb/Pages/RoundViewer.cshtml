@page
@model CS2DemoParserWeb.Pages.RoundViewerModel
@{
    ViewData["Title"] = "2D Round Viewer";
}

<div class="container-fluid">
    <div class="text-center mb-4">
        <h1 class="display-5">üé¨ 2D Round Viewer</h1>
        <p class="lead">Interactive tick-by-tick visualization of CS2 rounds</p>
    </div>

    <!-- Filters and Controls -->
    <div class="card mb-4 filters-card">
        <div class="card-body py-3">
            <div class="row align-items-end">
                <div class="col-md-3">
                    <label for="demoSelect" class="form-label fw-semibold">üìÅ Demo File</label>
                    <select class="form-select form-select-sm" id="demoSelect">
                        <option value="">Select Demo</option>
                    </select>
                </div>

                <div class="col-md-3">
                    <label for="roundSelect" class="form-label fw-semibold">üîÑ Round</label>
                    <select class="form-select form-select-sm" id="roundSelect">
                        <option value="">Select Round</option>
                    </select>
                </div>

                <div class="col-md-6 d-flex flex-wrap gap-2 align-items-end">
                    <button type="button" class="btn btn-primary btn-sm px-4" onclick="loadRoundData()">
                        <i class="fas fa-play me-2"></i>Load Round
                    </button>
                    <button type="button" class="btn btn-secondary btn-sm px-4" onclick="resetViewer()">
                        <i class="fas fa-refresh me-2"></i>Reset
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Round Info Panel -->
    <div class="card mb-4 d-none" id="roundInfoPanel">
        <div class="card-header">
            <h6 class="mb-0">
                <i class="fas fa-info-circle me-2"></i>Round Information
            </h6>
        </div>
        <div class="card-body py-2">
            <div class="row" id="roundInfoContent">
                <!-- Round info will be populated here -->
            </div>
        </div>
    </div>

    <!-- Main Viewer -->
    <div class="card">
        <div class="card-header d-flex justify-content-between align-items-center">
            <h5 class="card-title mb-0">
                <i class="fas fa-map me-2"></i>2D Round Visualization
            </h5>
            <div class="d-flex gap-2">
                <div class="btn-group btn-group-sm" role="group">
                    <button type="button" class="btn btn-outline-secondary" onclick="togglePlayPause()">
                        <i class="fas fa-play" id="playPauseIcon"></i>
                    </button>
                    <button type="button" class="btn btn-outline-secondary" onclick="previousTick()">
                        <i class="fas fa-step-backward"></i>
                    </button>
                    <button type="button" class="btn btn-outline-secondary" onclick="nextTick()">
                        <i class="fas fa-step-forward"></i>
                    </button>
                </div>
                <div class="btn-group btn-group-sm" role="group">
                    <button type="button" class="btn btn-outline-info" onclick="togglePlayerNames()">
                        <i class="fas fa-user-tag"></i> Names
                    </button>
                    <button type="button" class="btn btn-outline-info" onclick="toggleTrails()">
                        <i class="fas fa-route"></i> Trails
                    </button>
                    <button type="button" class="btn btn-outline-info" onclick="toggleEvents()">
                        <i class="fas fa-crosshairs"></i> Events
                    </button>
                </div>
            </div>
        </div>

        <div class="card-body p-0" style="height: 70vh; min-height: 600px;">
            <!-- Loading Overlay -->
            <div class="loading-overlay d-none" id="loadingOverlay">
                <div class="text-center">
                    <div class="spinner-border text-primary" role="status"></div>
                    <p class="mt-2 mb-0">Loading round data...</p>
                </div>
            </div>

            <!-- Map Container -->
            <div class="map-container" id="mapContainer" style="height: 100%; position: relative;">
                <div class="map-placeholder text-center d-flex align-items-center justify-content-center h-100">
                    <div>
                        <i class="fas fa-map fa-3x mb-3 text-muted"></i>
                        <p class="text-muted">Select a demo and round to begin viewing</p>
                    </div>
                </div>

                <!-- 2D Map Canvas -->
                <canvas id="roundCanvas" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 1px solid #ddd;"></canvas>

                <!-- Map Info Panel -->
                <div class="map-info-panel d-none" id="mapInfoPanel">
                    <div class="card">
                        <div class="card-body p-2">
                            <small class="text-muted" id="mapInfoContent">
                                <!-- Map info content -->
                            </small>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Timeline Controls -->
        <div class="card-footer" id="timelineControls" style="display: none;">
            <div class="row align-items-center">
                <div class="col-md-2">
                    <div class="d-flex align-items-center">
                        <label for="tickSlider" class="form-label mb-0 me-2">Tick:</label>
                        <span class="badge bg-primary" id="currentTick">0</span>
                    </div>
                </div>
                <div class="col-md-8">
                    <input type="range" class="form-range" id="tickSlider" min="0" max="100" value="0"
                           oninput="updateTickDisplay(this.value)" onchange="jumpToTick(this.value)">
                </div>
                <div class="col-md-2">
                    <div class="d-flex align-items-center justify-content-end">
                        <label class="form-label mb-0 me-2">Speed:</label>
                        <select class="form-select form-select-sm" id="playbackSpeed" onchange="updatePlaybackSpeed()" style="width: 80px;">
                            <option value="0.25">0.25x</option>
                            <option value="0.5">0.5x</option>
                            <option value="1" selected>1x</option>
                            <option value="2">2x</option>
                            <option value="4">4x</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Timeline Events -->
            <div class="mt-2" id="timelineEvents">
                <small class="text-muted">Timeline events will appear here</small>
            </div>
        </div>
    </div>
</div>

<style>
.filters-card {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(5px);
    border: 1px solid rgba(0, 0, 0, 0.1);
}

.loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.9);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.map-container {
    background: #f8f9fa;
    border-radius: 0.375rem;
}

.map-info-panel {
    position: absolute;
    top: 10px;
    right: 10px;
    max-width: 250px;
    z-index: 100;
}

#roundCanvas {
    cursor: crosshair;
}

.player-dot {
    position: absolute;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 2px solid white;
    transform: translate(-50%, -50%);
    z-index: 10;
    transition: all 0.1s ease;
}

.player-dot.ct {
    background-color: #007bff;
    border-color: white;
}

.player-dot.t {
    background-color: #dc3545;
    border-color: white;
}

.player-dot.dead {
    opacity: 0.3;
    filter: grayscale(100%);
}

.player-name {
    position: absolute;
    font-size: 10px;
    font-weight: bold;
    color: white;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    transform: translate(-50%, -20px);
    white-space: nowrap;
    z-index: 11;
}

.event-marker {
    position: absolute;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    z-index: 5;
}

.event-marker.kill {
    background-color: #ffc107;
    border: 1px solid white;
}

.event-marker.bomb {
    background-color: #fd7e14;
    border: 1px solid white;
}

.event-marker.grenade {
    background-color: #20c997;
    border: 1px solid white;
}

/* Animation for playback - removed due to Razor symbol conflict */

.player-dot.active {
    animation: pulse 0.5s ease-in-out;
}

/* Timeline styling */
.form-range::-webkit-slider-track {
    background: #dee2e6;
    border-radius: 0.25rem;
}

.form-range::-webkit-slider-thumb {
    background: #0d6efd;
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0,0,0,.1);
}

/* Responsive improvements - removed due to Razor symbol conflict */
</style>

<script>
// Global variables for round viewer
let currentRoundData = null;
let currentRoundEvents = [];
let currentTick = 0;
let minTick = 0;
let maxTick = 0;
let isPlaying = false;
let playbackInterval = null;
let playbackSpeed = 1;
let canvas = null;
let ctx = null;
let mapImage = null;
let showPlayerNames = true;
let showTrails = false;
let showEvents = true;
let playerTrails = new Map();

// Map configurations (exactly matching HeatmapService)
const mapConfigs = {
    'de_ancient': { PosX: -2953, PosY: 2164, Scale: 5, image: '/maps/de_ancient.png' },
    'de_anubis': { PosX: -2796, PosY: 3328, Scale: 5.22, image: '/maps/de_anubis.png' },
    'de_dust2': { PosX: -2476, PosY: 3239, Scale: 4.4, image: '/maps/de_dust2.png' },
    'de_inferno': { PosX: -2087, PosY: 3870, Scale: 4.9, image: '/maps/de_inferno.png' },
    'de_mirage': { PosX: -3230, PosY: 1713, Scale: 5.0, image: '/maps/de_mirage.png' },
    'de_nuke': { PosX: -3453, PosY: 2887, Scale: 7.0, image: '/maps/de_nuke.png' },
    'de_overpass': { PosX: -4831, PosY: 1781, Scale: 5.2, image: '/maps/de_overpass.png' },
    'de_vertigo': { PosX: -3168, PosY: 1762, Scale: 4.0, image: '/maps/de_vertigo.png' },
    'de_train': { PosX: -2308, PosY: 2078, Scale: 4.082077, image: '/maps/de_train.png' },
    'de_cache': { PosX: -2000, PosY: 3250, Scale: 5.5, image: '/maps/de_cache.png' }
};

// Convert heatmap data format to round viewer format
function convertHeatmapToRoundViewerFormat(heatmapPoints, mapName, roundNumber) {
    // Group points by player and create synthetic tick data
    const playerGroups = {};

    heatmapPoints.forEach(point => {
        const playerName = point.playerName;
        if (!playerGroups[playerName]) {
            playerGroups[playerName] = [];
        }
        playerGroups[playerName].push(point);
    });

    const roundViewerData = [];

    // Create synthetic tick progression for each player
    Object.entries(playerGroups).forEach(([playerName, points]) => {
        points.forEach((point, index) => {
            const tick = 3600 + (index * 32); // Start at tick 3600, increment by 32 ticks

            roundViewerData.push({
                RoundId: 24,
                RoundNumber: roundNumber,
                StartTick: 3600,
                EndTick: 8000,
                Duration: 60.0,
                WinnerTeam: "3",
                EndReason: "8",
                BombPlanted: false,
                BombDefused: false,
                BombExploded: false,
                MapName: mapName,
                DemoName: "demo.dem",
                PlayerId: Math.abs(playerName.split('').reduce((a,b) => (((a<<5)-a)+b.charCodeAt(0))|0, 0)),
                PlayerName: playerName,
                Team: point.team,
                Tick: tick,
                GameTime: tick / 32,
                PositionX: point.x,
                PositionY: point.y,
                PositionZ: point.z || 0,
                ViewAngleX: 0,
                ViewAngleY: Math.random() * 360 - 180, // Random view angle for demo
                IsAlive: true,
                Health: 100,
                Armor: 100,
                ActiveWeapon: "CKnife",
                Money: 800,
                IsScoped: false,
                IsWalking: false,
                IsCrouching: false,
                IsDefusing: false,
                IsPlanting: false,
                InSmoke: false,
                IsBlind: false
            });
        });
    });

    return roundViewerData;
}

// Initialize page
document.addEventListener('DOMContentLoaded', function() {
    initializeCanvas();
    loadDemoList();
});

function initializeCanvas() {
    canvas = document.getElementById('roundCanvas');
    ctx = canvas.getContext('2d');

    // Set canvas size
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Add click handler for map interaction
    canvas.addEventListener('click', handleCanvasClick);
    canvas.addEventListener('mousemove', handleCanvasMouseMove);
}

function resizeCanvas() {
    const container = document.getElementById('mapContainer');
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;

    if (currentRoundData) {
        drawCurrentFrame();
    }
}

async function loadDemoList() {
    try {
        const response = await fetch('/api/demo/demos');
        if (response.ok) {
            const demos = await response.json();
            const demoSelect = document.getElementById('demoSelect');

            demoSelect.innerHTML = '<option value="">Select Demo</option>';
            demos.forEach(demo => {
                const option = document.createElement('option');
                option.value = demo.id;
                option.textContent = `${demo.fileName} (${demo.mapName})`;
                demoSelect.appendChild(option);
            });

            demoSelect.addEventListener('change', loadRoundsForDemo);
        }
    } catch (error) {
        console.error('Error loading demos:', error);
    }
}

async function loadRoundsForDemo() {
    const demoId = document.getElementById('demoSelect').value;
    if (!demoId) {
        document.getElementById('roundSelect').innerHTML = '<option value="">Select Round</option>';
        return;
    }

    try {
        console.log('Loading rounds for demoId:', demoId);
        const response = await fetch(`/api/round-viewer/rounds?demoId=${demoId}`);
        console.log('Response status:', response.status);

        if (response.ok) {
            const data = await response.json();
            console.log('Response data:', data);
            const roundSelect = document.getElementById('roundSelect');

            roundSelect.innerHTML = '<option value="">Select Round</option>';
            if (data.data && Array.isArray(data.data)) {
                data.data.forEach(round => {
                    const option = document.createElement('option');
                    option.value = round.Id;
                    option.textContent = `Round ${round.RoundNumber} - ${round.WinnerTeam || 'Unknown'} (${round.Duration?.toFixed(1)}s)`;
                    roundSelect.appendChild(option);
                });
            } else {
                console.error('Invalid response structure:', data);
            }
        } else {
            const errorText = await response.text();
            console.error('API error:', response.status, errorText);
        }
    } catch (error) {
        console.error('Error loading rounds:', error);
    }
}

async function loadRoundData() {
    const roundId = document.getElementById('roundSelect').value;
    const demoId = document.getElementById('demoSelect').value;

    if (!roundId || !demoId) {
        alert('Please select a demo and round');
        return;
    }

    // Get the round number from the selected option text
    const roundSelect = document.getElementById('roundSelect');
    const selectedOption = roundSelect.options[roundSelect.selectedIndex];
    const roundText = selectedOption.textContent;
    const roundNumber = parseInt(roundText.match(/Round (\d+)/)[1]);

    console.log(`Loading Round ${roundNumber} from Demo ${demoId} (roundId: ${roundId})`);

    showLoading(true);

    try {
        console.log('Attempting to use heatmap data for accurate positions...');

        // Get the map name for the selected demo
        const demoResponse = await fetch('/api/demo/demos');
        const demos = await demoResponse.json();
        const selectedDemo = demos.find(d => d.id == demoId);
        const mapName = selectedDemo?.mapName || 'de_mirage';

        // Use heatmap API for accurate position data, but modify it for round viewer needs
        const [heatmapResponse, eventsResponse] = await Promise.all([
            fetch(`/api/heatmap/player-positions?demoId=${demoId}&mapName=${mapName}&roundNumber=${roundNumber}`),
            fetch(`/api/round-viewer/round-events?roundId=${roundId}`)
        ]);

        if (heatmapResponse.ok && eventsResponse.ok) {
            const heatmapData = await heatmapResponse.json();
            const eventsData = await eventsResponse.json();

            console.log('Heatmap data received:', heatmapData.points.length, 'points');
            console.log('Sample heatmap point:', heatmapData.points[0]);

            // Convert heatmap data format to round viewer format
            const convertedData = convertHeatmapToRoundViewerFormat(heatmapData.points, mapName, roundNumber);
            console.log('Converted data:', convertedData.length, 'records');
            console.log('Sample converted record:', convertedData[0]);

            const roundData = {
                title: `Round Data - Tick All`,
                roundId: parseInt(roundId),
                requestedTick: null,
                data: convertedData,
                totalRecords: convertedData.length
            };

            currentRoundData = roundData.data;
            currentRoundEvents = eventsData.data;

            if (currentRoundData.length > 0) {
                console.log('Round data loaded successfully, count:', currentRoundData.length);
                processRoundData();
                showRoundInfo(currentRoundData[0]);
                console.log('Loading map for:', currentRoundData[0].MapName, 'from round data:', currentRoundData[0]);
                loadMapImage(currentRoundData[0].MapName);
                setupTimeline();
                showControls(true);
                console.log('All setup functions called');
            } else {
                alert('No data found for this round');
            }
        } else {
            console.error('Failed to load data:', {
                heatmapStatus: heatmapResponse.status,
                eventsStatus: eventsResponse.status,
                heatmapOk: heatmapResponse.ok,
                eventsOk: eventsResponse.ok
            });

            const heatmapError = await heatmapResponse.text();
            const eventsError = await eventsResponse.text();
            console.error('Heatmap error:', heatmapError);
            console.error('Events error:', eventsError);

            throw new Error(`Failed to load round data - Heatmap: ${heatmapResponse.status}, Events: ${eventsResponse.status}`);
        }
    } catch (error) {
        console.error('Error loading round data:', error);
        alert('Error loading round data: ' + error.message);
    } finally {
        showLoading(false);
    }
}

function processRoundData() {
    if (!currentRoundData || currentRoundData.length === 0) return;

    // Use the round's actual start and end ticks for proper timeline
    const roundInfo = currentRoundData[0];
    minTick = roundInfo.StartTick;
    maxTick = roundInfo.EndTick || roundInfo.StartTick + 32000; // Fallback if EndTick is null
    currentTick = minTick; // Start at the actual beginning of the round

    // Get available data tick range for comparison
    const ticks = currentRoundData.map(d => d.Tick).filter(t => t != null);
    const dataMinTick = Math.min(...ticks);
    const dataMaxTick = Math.max(...ticks);

    console.log(`Using round tick range: ${minTick} to ${maxTick}`);
    console.log(`Available data tick range: ${dataMinTick} to ${dataMaxTick}`);
    console.log('Processing round data with proper map configurations');

    // Group data by tick for efficient lookup
    const tickData = new Map();
    currentRoundData.forEach(row => {
        if (!tickData.has(row.Tick)) {
            tickData.set(row.Tick, []);
        }
        tickData.get(row.Tick).push(row);
    });

    currentRoundData.tickData = tickData;

    // Initialize player trails
    playerTrails.clear();
}

function loadMapImage(mapName) {
    console.log('Loading map image for:', mapName);
    const config = mapConfigs[mapName];
    if (!config) {
        console.warn('No map config found for:', mapName);
        console.log('Available map configs:', Object.keys(mapConfigs));
        return;
    }

    console.log('Map config:', config);
    mapImage = new Image();
    mapImage.onload = function() {
        console.log('Map image loaded successfully, dimensions:', mapImage.width, 'x', mapImage.height);
        drawCurrentFrame();
    };
    mapImage.onerror = function() {
        console.error('Failed to load map image:', config.image);
        drawCurrentFrame(); // Still draw without map background
    };
    mapImage.src = config.image;
}

function setupTimeline() {
    const slider = document.getElementById('tickSlider');
    slider.min = minTick;
    slider.max = maxTick;
    slider.value = currentTick;

    updateTickDisplay(currentTick);

    // Update the timeline label to show this is relative to round start
    const tickLabel = document.querySelector('label[for="tickSlider"]');
    if (tickLabel) {
        tickLabel.textContent = 'Tick (relative):';
    }

    // Show timeline events
    displayTimelineEvents();
}

function showRoundInfo(roundData) {
    const panel = document.getElementById('roundInfoPanel');
    const content = document.getElementById('roundInfoContent');

    content.innerHTML = `
        <div class="col-md-2">
            <strong>Round:</strong> ${roundData.RoundNumber}
        </div>
        <div class="col-md-2">
            <strong>Map:</strong> ${roundData.MapName}
        </div>
        <div class="col-md-2">
            <strong>Winner:</strong> ${roundData.WinnerTeam || 'Unknown'}
        </div>
        <div class="col-md-2">
            <strong>Duration:</strong> ${roundData.Duration?.toFixed(1)}s
        </div>
        <div class="col-md-2">
            <strong>End Reason:</strong> ${roundData.EndReason || 'Unknown'}
        </div>
        <div class="col-md-2">
            <strong>Bomb:</strong>
            ${roundData.BombPlanted ? 'üí£' : ''}
            ${roundData.BombDefused ? 'üîß' : ''}
            ${roundData.BombExploded ? 'üí•' : ''}
        </div>
    `;

    panel.classList.remove('d-none');
}

function displayTimelineEvents() {
    const container = document.getElementById('timelineEvents');
    if (currentRoundEvents.length === 0) {
        container.innerHTML = '<small class="text-muted">No events found for this round</small>';
        return;
    }

    const eventTypes = currentRoundEvents.reduce((acc, event) => {
        acc[event.EventType] = (acc[event.EventType] || 0) + 1;
        return acc;
    }, {});

    const eventSummary = Object.entries(eventTypes)
        .map(([type, count]) => `${getEventIcon(type)} ${count} ${type}${count > 1 ? 's' : ''}`)
        .join(' ‚Ä¢ ');

    container.innerHTML = `<small class="text-muted">Events: ${eventSummary}</small>`;
}

function getEventIcon(eventType) {
    switch (eventType) {
        case 'kill': return 'üíÄ';
        case 'bomb': return 'üí£';
        case 'grenade': return 'üí•';
        default: return '‚Ä¢';
    }
}

// Transform game coordinates to canvas coordinates - EXACTLY matching HeatmapImageService
function transformToCanvas(gameX, gameY, mapName) {
    const config = mapConfigs[mapName];
    if (!config) {
        console.warn('No map config found for:', mapName);
        return { x: 0, y: 0 };
    }

    // EXACT same transformation as HeatmapImageService.ConvertToImageX/Y
    const normalizedX = (gameX - config.PosX) / config.Scale;
    const normalizedY = (config.PosY - gameY) / config.Scale; // Flip Y axis for CS2

    // Convert to image coordinates (1024x1024 base) - EXACT same as HeatmapImageService
    const imageWidth = 1024;
    const imageHeight = 1024;
    const heatmapImageX = normalizedX * imageWidth / 1024; // This is just normalizedX
    const heatmapImageY = normalizedY * imageHeight / 1024; // This is just normalizedY

    // Now scale to canvas size - match how the map image is actually drawn
    const canvasAspectRatio = canvas.width / canvas.height;
    const mapAspectRatio = 1.0; // Map is square

    let canvasX, canvasY;

    if (canvasAspectRatio > mapAspectRatio) {
        // Canvas wider - map uses full height, centered horizontally
        const mapPixelSize = canvas.height;
        const offsetX = (canvas.width - mapPixelSize) / 2;
        canvasX = heatmapImageX * mapPixelSize + offsetX;
        canvasY = heatmapImageY * mapPixelSize;
    } else {
        // Canvas taller - map uses full width, centered vertically
        const mapPixelSize = canvas.width;
        const offsetY = (canvas.height - mapPixelSize) / 2;
        canvasX = heatmapImageX * mapPixelSize;
        canvasY = heatmapImageY * mapPixelSize + offsetY;
    }

    // Debug logging - always log first transformation for debugging
    if (!window.debugLoggedFirst) {
        console.log(`FIRST TRANSFORM: game(${gameX}, ${gameY}) -> normalized(${normalizedX.toFixed(1)}, ${normalizedY.toFixed(1)}) -> heatmapImage(${heatmapImageX.toFixed(1)}, ${heatmapImageY.toFixed(1)}) -> canvas(${canvasX.toFixed(0)}, ${canvasY.toFixed(0)})`);
        console.log(`Canvas: ${canvas.width}x${canvas.height}, Aspect: ${canvasAspectRatio.toFixed(2)}`);
        console.log(`Map config for ${mapName}:`, config);
        window.debugLoggedFirst = true;
    }

    return {
        x: canvasX,
        y: canvasY
    };
}

function drawCurrentFrame() {
    console.log('drawCurrentFrame called');
    if (!ctx) {
        console.log('No canvas context available');
        return;
    }

    console.log('Canvas size:', canvas.width, 'x', canvas.height);
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw map image if available, respecting aspect ratio
    if (mapImage && mapImage.complete) {
        // Calculate the same aspect ratio scaling as the coordinate transformation
        const canvasAspectRatio = canvas.width / canvas.height;
        const mapAspectRatio = 1.0; // Map is square

        if (canvasAspectRatio > mapAspectRatio) {
            // Canvas is wider - center map horizontally
            const scale = canvas.height;
            const offsetX = (canvas.width - scale) / 2;
            ctx.drawImage(mapImage, offsetX, 0, scale, scale);
        } else {
            // Canvas is taller - center map vertically
            const scale = canvas.width;
            const offsetY = (canvas.height - scale) / 2;
            ctx.drawImage(mapImage, 0, offsetY, scale, scale);
        }
    } else {
        // Draw background
        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw grid
        drawGrid();
    }

    if (!currentRoundData || !currentRoundData.tickData) return;

    // Find the nearest available tick data
    let tickData = currentRoundData.tickData.get(currentTick);
    if (!tickData) {
        // Find the closest tick with data
        const availableTicks = Array.from(currentRoundData.tickData.keys()).sort((a, b) => a - b);
        let nearestTick = availableTicks.reduce((prev, curr) =>
            Math.abs(curr - currentTick) < Math.abs(prev - currentTick) ? curr : prev
        );
        tickData = currentRoundData.tickData.get(nearestTick);

        if (!tickData) return;

        // Log when using nearest tick
        if (Math.abs(nearestTick - currentTick) > 0) {
            console.log(`Using nearest tick ${nearestTick} for requested tick ${currentTick}`);
        }
    }

    const mapName = tickData[0].MapName;

    // Draw player trails if enabled
    if (showTrails) {
        drawPlayerTrails(mapName);
    }

    // Draw events at current tick
    if (showEvents) {
        drawEventsAtTick(currentTick, mapName);
    }

    // Draw players
    drawPlayers(tickData, mapName);

    // Update trails
    if (showTrails) {
        updatePlayerTrails(tickData, mapName);
    }
}

function drawGrid() {
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 1;

    const gridSize = 50;

    for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }

    for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
}

function drawPlayers(tickData, mapName) {
    console.log(`Drawing ${tickData.length} players for map: ${mapName}`);

    tickData.forEach((player, index) => {
        if (player.PositionX == null || player.PositionY == null) return;

        // Log first few players' raw coordinates
        if (index < 3) {
            console.log(`Player ${player.PlayerName}: Raw game coords (${player.PositionX}, ${player.PositionY})`);
        }

        const pos = transformToCanvas(player.PositionX, player.PositionY, mapName);

        // Log transformed coordinates for first few players
        if (index < 3) {
            console.log(`Player ${player.PlayerName}: Canvas coords (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`);
        }

        // Determine player color
        const isAlive = player.IsAlive;
        const team = player.Team?.toLowerCase();

        let color = '#808080'; // Default gray
        if (team === 'ct' || team === '3') color = '#007bff'; // Blue for CT
        if (team === 't' || team === '2') color = '#dc3545';  // Red for T

        // Draw player dot
        ctx.save();
        ctx.globalAlpha = isAlive ? 1.0 : 0.3;

        // Player circle
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 8, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = isAlive ? 'white' : 'gray';
        ctx.lineWidth = 2;
        ctx.stroke();

        // View direction indicator
        if (isAlive && player.ViewAngleY != null) {
            const angle = (player.ViewAngleY * Math.PI) / 180;
            const lineLength = 15;
            const endX = pos.x + Math.cos(angle) * lineLength;
            const endY = pos.y + Math.sin(angle) * lineLength;

            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = isAlive ? 'white' : 'gray';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Player name
        if (showPlayerNames && player.PlayerName) {
            ctx.font = '12px Arial';
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.textAlign = 'center';

            ctx.strokeText(player.PlayerName, pos.x, pos.y - 12);
            ctx.fillText(player.PlayerName, pos.x, pos.y - 12);
        }

        // Health indicator
        if (isAlive && player.Health != null) {
            const healthWidth = 20;
            const healthHeight = 3;
            const healthPercent = player.Health / 100;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillRect(pos.x - healthWidth/2, pos.y + 12, healthWidth, healthHeight);

            ctx.fillStyle = healthPercent > 0.5 ? '#28a745' : healthPercent > 0.2 ? '#ffc107' : '#dc3545';
            ctx.fillRect(pos.x - healthWidth/2, pos.y + 12, healthWidth * healthPercent, healthHeight);
        }

        ctx.restore();
    });
}

function drawEventsAtTick(tick, mapName) {
    const events = currentRoundEvents.filter(e => e.Tick === tick);

    events.forEach(event => {
        if (event.PositionX == null || event.PositionY == null) return;

        const pos = transformToCanvas(event.PositionX, event.PositionY, mapName);

        let color = '#ffc107'; // Default yellow
        if (event.EventType === 'kill') color = '#dc3545'; // Red for kills
        if (event.EventType === 'bomb') color = '#fd7e14'; // Orange for bomb
        if (event.EventType === 'grenade') color = '#20c997'; // Teal for grenades

        // Draw event marker
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 4, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.stroke();
    });
}

function updatePlayerTrails(tickData, mapName) {
    tickData.forEach(player => {
        if (player.PositionX == null || player.PositionY == null || !player.IsAlive) return;

        const playerId = player.PlayerId;
        if (!playerTrails.has(playerId)) {
            playerTrails.set(playerId, []);
        }

        const trail = playerTrails.get(playerId);
        const pos = transformToCanvas(player.PositionX, player.PositionY, mapName);

        trail.push({ x: pos.x, y: pos.y, tick: currentTick });

        // Limit trail length
        if (trail.length > 50) {
            trail.shift();
        }
    });
}

function drawPlayerTrails(mapName) {
    playerTrails.forEach((trail, playerId) => {
        if (trail.length < 2) return;

        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';

        ctx.beginPath();
        ctx.moveTo(trail[0].x, trail[0].y);

        for (let i = 1; i < trail.length; i++) {
            ctx.lineTo(trail[i].x, trail[i].y);
        }

        ctx.stroke();
        ctx.restore();
    });
}

// Playback controls
function togglePlayPause() {
    if (isPlaying) {
        pausePlayback();
    } else {
        startPlayback();
    }
}

function startPlayback() {
    if (!currentRoundData) return;

    isPlaying = true;
    document.getElementById('playPauseIcon').className = 'fas fa-pause';

    const interval = 1000 / (10 * playbackSpeed); // 10 ticks per second base rate

    playbackInterval = setInterval(() => {
        if (currentTick >= maxTick) {
            pausePlayback();
            return;
        }

        currentTick += Math.max(1, Math.floor(playbackSpeed * 2));
        updateDisplay();
    }, interval);
}

function pausePlayback() {
    isPlaying = false;
    document.getElementById('playPauseIcon').className = 'fas fa-play';

    if (playbackInterval) {
        clearInterval(playbackInterval);
        playbackInterval = null;
    }
}

function previousTick() {
    if (!currentRoundData) return;

    currentTick = Math.max(minTick, currentTick - Math.max(1, Math.floor(playbackSpeed * 5)));
    updateDisplay();
}

function nextTick() {
    if (!currentRoundData) return;

    currentTick = Math.min(maxTick, currentTick + Math.max(1, Math.floor(playbackSpeed * 5)));
    updateDisplay();
}

function jumpToTick(tick) {
    currentTick = parseInt(tick);
    updateDisplay();

    if (isPlaying) {
        pausePlayback();
    }
}

function updateTickDisplay(tick) {
    const displayTick = tick || currentTick;
    const relativeTick = displayTick - minTick; // Show tick relative to round start
    document.getElementById('currentTick').textContent = relativeTick;
    document.getElementById('tickSlider').value = displayTick;
}

function updatePlaybackSpeed() {
    const speed = parseFloat(document.getElementById('playbackSpeed').value);
    playbackSpeed = speed;

    // Restart playback if currently playing
    if (isPlaying) {
        pausePlayback();
        startPlayback();
    }
}

function updateDisplay() {
    updateTickDisplay();
    drawCurrentFrame();
}

// UI toggles
function togglePlayerNames() {
    showPlayerNames = !showPlayerNames;
    drawCurrentFrame();

    const btn = event.target.closest('button');
    btn.classList.toggle('active');
}

function toggleTrails() {
    showTrails = !showTrails;
    if (!showTrails) {
        playerTrails.clear();
    }
    drawCurrentFrame();

    const btn = event.target.closest('button');
    btn.classList.toggle('active');
}

function toggleEvents() {
    showEvents = !showEvents;
    drawCurrentFrame();

    const btn = event.target.closest('button');
    btn.classList.toggle('active');
}

// Canvas interaction
function handleCanvasClick(event) {
    if (!currentRoundData) return;

    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    // Convert to game coordinates and show info
    showMapInfo(x, y);
}

function handleCanvasMouseMove(event) {
    if (!currentRoundData) return;

    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    // Show cursor coordinates
    canvas.style.cursor = 'crosshair';
}

function showMapInfo(x, y) {
    const panel = document.getElementById('mapInfoPanel');
    const content = document.getElementById('mapInfoContent');

    // Convert canvas coordinates to game coordinates
    if (currentRoundData && currentRoundData.length > 0) {
        const mapName = currentRoundData[0].MapName;
        const config = mapConfigs[mapName];
        if (config) {
            const normalizedX = x / canvas.width;
            const normalizedY = y / canvas.height;

            const gameX = (normalizedX * 1024 * config.Scale) + config.PosX;
            const gameY = config.PosY - (normalizedY * 1024 * config.Scale);

            const relativeTick = currentTick - minTick;
            content.innerHTML = `
                <strong>Position:</strong><br>
                Game: (${gameX.toFixed(0)}, ${gameY.toFixed(0)})<br>
                Canvas: (${x.toFixed(0)}, ${y.toFixed(0)})<br>
                <strong>Tick:</strong> ${relativeTick} (abs: ${currentTick})
            `;

            panel.classList.remove('d-none');
        }
    }
}

// Utility functions
function showLoading(show) {
    const overlay = document.getElementById('loadingOverlay');
    overlay.classList.toggle('d-none', !show);
}

function showControls(show) {
    console.log('showControls called with:', show);

    const timelineControls = document.getElementById('timelineControls');
    const roundCanvas = document.getElementById('roundCanvas');
    const mapPlaceholder = document.querySelector('.map-placeholder');

    console.log('Elements found:', {
        timelineControls: !!timelineControls,
        roundCanvas: !!roundCanvas,
        mapPlaceholder: !!mapPlaceholder
    });

    try {
        if (timelineControls) {
            timelineControls.style.display = show ? 'block' : 'none';
            console.log('Timeline controls display set to:', timelineControls.style.display);
        }

        if (roundCanvas) {
            roundCanvas.style.display = show ? 'block' : 'none';
            console.log('Canvas display set to:', roundCanvas.style.display);
        }

        if (mapPlaceholder) {
            mapPlaceholder.style.display = show ? 'none' : 'flex';
            console.log('Placeholder display set to:', mapPlaceholder.style.display);
        }

        console.log('Canvas display after change:', roundCanvas ? roundCanvas.style.display : 'null');
    } catch (error) {
        console.error('Error in showControls:', error);
    }
}

function resetViewer() {
    pausePlayback();
    currentRoundData = null;
    currentRoundEvents = [];
    currentTick = 0;
    playerTrails.clear();

    showControls(false);
    document.getElementById('roundInfoPanel').classList.add('d-none');
    document.getElementById('mapInfoPanel').classList.add('d-none');

    document.getElementById('demoSelect').value = '';
    document.getElementById('roundSelect').innerHTML = '<option value="">Select Round</option>';

    if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
}
</script>